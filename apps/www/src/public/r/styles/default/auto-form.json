{
  "name": "auto-form",
  "type": "registry:ui",
  "dependencies": [
    "vee-validate",
    "@vee-validate/zod",
    "zod",
    "reka-ui"
  ],
  "registryDependencies": [
    "form",
    "accordion",
    "button",
    "separator",
    "checkbox",
    "switch",
    "calendar",
    "popover",
    "label",
    "radio-group",
    "select",
    "input",
    "textarea"
  ],
  "files": [
    {
      "path": "ui/auto-form/AutoForm.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends ZodObjectOrWrapped\">\r\nimport type { FormContext, GenericObject } from \"vee-validate\"\r\nimport type { z, ZodAny } from \"zod\"\r\nimport type { Config, ConfigItem, Dependency, Shape } from \"./interface\"\r\nimport type { ZodObjectOrWrapped } from \"./utils\"\r\nimport { toTypedSchema } from \"@vee-validate/zod\"\r\nimport { computed, toRefs } from \"vue\"\r\nimport { Form } from \"@/registry/default/ui/form\"\r\nimport AutoFormField from \"./AutoFormField.vue\"\r\nimport { provideDependencies } from \"./dependencies\"\nimport { getBaseSchema, getBaseType, getDefaultValueInZodStack, getObjectFormSchema } from \"./utils\"\r\n\r\nconst props = defineProps<{\r\n  schema: T\r\n  form?: FormContext<GenericObject>\r\n  fieldConfig?: Config<z.infer<T>>\r\n  dependencies?: Dependency<z.infer<T>>[]\r\n}>()\r\n\r\nconst emits = defineEmits<{\r\n  submit: [event: z.infer<T>]\r\n}>()\r\n\r\nconst { dependencies } = toRefs(props)\r\nprovideDependencies(dependencies)\r\n\r\nconst shapes = computed(() => {\r\n  // @ts-expect-error ignore {} not assignable to object\r\n  const val: { [key in keyof T]: Shape } = {}\r\n  const baseSchema = getObjectFormSchema(props.schema)\r\n  const shape = baseSchema.shape\r\n  Object.keys(shape).forEach((name) => {\r\n    const item = shape[name] as ZodAny\r\n    const baseItem = getBaseSchema(item) as ZodAny\r\n    let options = (baseItem && \"values\" in baseItem._def) ? baseItem._def.values as string[] : undefined\r\n    if (!Array.isArray(options) && typeof options === \"object\")\r\n      options = Object.values(options)\r\n\r\n    val[name as keyof T] = {\r\n      type: getBaseType(item),\r\n      default: getDefaultValueInZodStack(item),\r\n      options,\r\n      required: ![\"ZodOptional\", \"ZodNullable\"].includes(item._def.typeName),\r\n      schema: baseItem,\r\n    }\r\n  })\r\n  return val\r\n})\r\n\r\nconst fields = computed(() => {\r\n  // @ts-expect-error ignore {} not assignable to object\r\n  const val: { [key in keyof z.infer<T>]: { shape: Shape, fieldName: string, config: ConfigItem } } = {}\r\n  for (const key in shapes.value) {\r\n    const shape = shapes.value[key]\r\n    val[key as keyof z.infer<T>] = {\r\n      shape,\r\n      config: props.fieldConfig?.[key] as ConfigItem,\r\n      fieldName: key,\r\n    }\r\n  }\r\n  return val\r\n})\r\n\r\nconst formComponent = computed(() => props.form ? \"form\" : Form)\r\nconst formComponentProps = computed(() => {\r\n  if (props.form) {\r\n    return {\r\n      onSubmit: props.form.handleSubmit(val => emits(\"submit\", val)),\r\n    }\r\n  }\r\n  else {\r\n    const formSchema = toTypedSchema(props.schema)\r\n    return {\r\n      keepValues: true,\r\n      validationSchema: formSchema,\r\n      onSubmit: (val: GenericObject) => emits(\"submit\", val),\r\n    }\r\n  }\r\n})\r\n</script>\r\n\r\n<template>\r\n  <component\r\n    :is=\"formComponent\"\r\n    v-bind=\"formComponentProps\"\r\n  >\r\n    <slot name=\"customAutoForm\" :fields=\"fields\">\r\n      <template v-for=\"(shape, key) of shapes\" :key=\"key\">\r\n        <slot\r\n          :shape=\"shape\"\r\n          :name=\"key.toString() as keyof z.infer<T>\"\r\n          :field-name=\"key.toString()\"\r\n          :config=\"fieldConfig?.[key as keyof typeof fieldConfig] as ConfigItem\"\r\n        >\r\n          <AutoFormField\r\n            :config=\"fieldConfig?.[key as keyof typeof fieldConfig] as ConfigItem\"\r\n            :field-name=\"key.toString()\"\r\n            :shape=\"shape\"\r\n          />\r\n        </slot>\r\n      </template>\r\n    </slot>\r\n\r\n    <slot :shapes=\"shapes\" />\r\n  </component>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormField.vue",
      "content": "<script setup lang=\"ts\" generic=\"U extends ZodAny\">\r\nimport type { ZodAny } from \"zod\"\r\nimport type { Config, ConfigItem, Shape } from \"./interface\"\r\nimport { computed } from \"vue\"\r\nimport { DEFAULT_ZOD_HANDLERS, INPUT_COMPONENTS } from \"./constant\"\r\nimport useDependencies from \"./dependencies\"\r\n\r\nconst props = defineProps<{\r\n  fieldName: string\r\n  shape: Shape\r\n  config?: ConfigItem | Config<U>\r\n}>()\r\n\r\nfunction isValidConfig(config: any): config is ConfigItem {\r\n  return !!config?.component\r\n}\r\n\r\nconst delegatedProps = computed(() => {\r\n  if ([\"ZodObject\", \"ZodArray\"].includes(props.shape?.type))\r\n    return { schema: props.shape?.schema }\r\n  return undefined\r\n})\r\n\r\nconst { isDisabled, isHidden, isRequired, overrideOptions } = useDependencies(props.fieldName)\r\n</script>\r\n\r\n<template>\r\n  <component\r\n    :is=\"isValidConfig(config)\r\n      ? typeof config.component === 'string'\r\n        ? INPUT_COMPONENTS[config.component!]\r\n        : config.component\r\n      : INPUT_COMPONENTS[DEFAULT_ZOD_HANDLERS[shape.type]] \"\r\n    v-if=\"!isHidden\"\r\n    :field-name=\"fieldName\"\r\n    :label=\"shape.schema?.description\"\r\n    :required=\"isRequired || shape.required\"\r\n    :options=\"overrideOptions || shape.options\"\r\n    :disabled=\"isDisabled\"\r\n    :config=\"config\"\r\n    v-bind=\"delegatedProps\"\r\n  >\r\n    <slot />\r\n  </component>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormFieldArray.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends z.ZodAny\">\r\nimport type { Config, ConfigItem } from \"./interface\"\r\nimport { PlusIcon, TrashIcon } from \"lucide-vue-next\"\r\nimport { FieldArray, FieldContextKey, useField } from \"vee-validate\"\r\nimport { computed, provide } from \"vue\"\r\nimport * as z from \"zod\"\r\nimport { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from \"@/registry/default/ui/accordion\"\r\nimport { Button } from \"@/registry/default/ui/button\"\r\nimport { FormItem, FormMessage } from \"@/registry/default/ui/form\"\r\nimport { Separator } from \"@/registry/default/ui/separator\"\r\nimport AutoFormField from \"./AutoFormField.vue\"\r\nimport AutoFormLabel from \"./AutoFormLabel.vue\"\r\nimport { beautifyObjectName, getBaseType } from \"./utils\"\r\n\r\nconst props = defineProps<{\r\n  fieldName: string\r\n  required?: boolean\r\n  config?: Config<T>\r\n  schema?: z.ZodArray<T>\r\n  disabled?: boolean\r\n}>()\r\n\r\nfunction isZodArray(\r\n  item: z.ZodArray<any> | z.ZodDefault<any>,\r\n): item is z.ZodArray<any> {\r\n  return item instanceof z.ZodArray\r\n}\r\n\r\nfunction isZodDefault(\r\n  item: z.ZodArray<any> | z.ZodDefault<any>,\r\n): item is z.ZodDefault<any> {\r\n  return item instanceof z.ZodDefault\r\n}\r\n\r\nconst itemShape = computed(() => {\r\n  if (!props.schema)\r\n    return\r\n\r\n  const schema: z.ZodAny = isZodArray(props.schema)\r\n    ? props.schema._def.type\r\n    : isZodDefault(props.schema)\r\n    // @ts-expect-error missing schema\r\n      ? props.schema._def.innerType._def.type\r\n      : null\r\n\r\n  return {\r\n    type: getBaseType(schema),\r\n    schema,\r\n  }\r\n})\r\n\r\nconst fieldContext = useField(props.fieldName)\r\n// @ts-expect-error ignore missing `id`\r\nprovide(FieldContextKey, fieldContext)\r\n</script>\r\n\r\n<template>\r\n  <FieldArray v-slot=\"{ fields, remove, push }\" as=\"section\" :name=\"fieldName\">\r\n    <slot v-bind=\"props\">\r\n      <Accordion type=\"multiple\" class=\"w-full\" collapsible :disabled=\"disabled\" as-child>\r\n        <FormItem>\r\n          <AccordionItem :value=\"fieldName\" class=\"border-none\">\r\n            <AccordionTrigger>\r\n              <AutoFormLabel class=\"text-base\" :required=\"required\">\r\n                {{ schema?.description || beautifyObjectName(fieldName) }}\r\n              </AutoFormLabel>\r\n            </AccordionTrigger>\r\n\r\n            <AccordionContent>\r\n              <template v-for=\"(field, index) of fields\" :key=\"field.key\">\r\n                <div class=\"mb-4 p-1\">\r\n                  <AutoFormField\r\n                    :field-name=\"`${fieldName}[${index}]`\"\r\n                    :label=\"fieldName\"\r\n                    :shape=\"itemShape!\"\r\n                    :config=\"config as ConfigItem\"\r\n                  />\r\n\r\n                  <div class=\"!my-4 flex justify-end\">\r\n                    <Button\r\n                      type=\"button\"\r\n                      size=\"icon\"\r\n                      variant=\"secondary\"\r\n                      @click=\"remove(index)\"\r\n                    >\r\n                      <TrashIcon :size=\"16\" />\r\n                    </Button>\r\n                  </div>\r\n                  <Separator v-if=\"!field.isLast\" />\r\n                </div>\r\n              </template>\r\n\r\n              <Button\r\n                type=\"button\"\r\n                variant=\"secondary\"\r\n                class=\"mt-4 flex items-center\"\r\n                @click=\"push(null)\"\r\n              >\r\n                <PlusIcon class=\"mr-2\" :size=\"16\" />\r\n                Add\r\n              </Button>\r\n            </AccordionContent>\r\n\r\n            <FormMessage />\r\n          </AccordionItem>\r\n        </FormItem>\r\n      </Accordion>\r\n    </slot>\r\n  </FieldArray>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormFieldBoolean.vue",
      "content": "<script setup lang=\"ts\">\r\nimport type { FieldProps } from \"./interface\"\r\nimport { computed } from \"vue\"\r\nimport { Checkbox } from \"@/registry/default/ui/checkbox\"\r\nimport { FormControl, FormDescription, FormField, FormItem, FormMessage } from \"@/registry/default/ui/form\"\r\nimport { Switch } from \"@/registry/default/ui/switch\"\r\nimport AutoFormLabel from \"./AutoFormLabel.vue\"\r\nimport { beautifyObjectName, maybeBooleanishToBoolean } from \"./utils\"\r\n\r\nconst props = defineProps<FieldProps>()\r\n\r\nconst booleanComponent = computed(() => props.config?.component === \"switch\" ? Switch : Checkbox)\r\n</script>\r\n\r\n<template>\r\n  <FormField v-slot=\"slotProps\" :name=\"fieldName\">\r\n    <FormItem>\r\n      <div class=\"space-y-0 mb-3 flex items-center gap-3\">\r\n        <FormControl>\r\n          <slot v-bind=\"slotProps\">\r\n            <component\r\n              :is=\"booleanComponent\"\r\n              :disabled=\"maybeBooleanishToBoolean(config?.inputProps?.disabled) ?? disabled\"\r\n              :name=\"slotProps.componentField.name\"\r\n              :model-value=\"slotProps.componentField.modelValue\"\r\n              @update:model-value=\"slotProps.componentField['onUpdate:modelValue']\"\r\n            />\r\n          </slot>\r\n        </FormControl>\r\n        <AutoFormLabel v-if=\"!config?.hideLabel\" :required=\"required\">\r\n          {{ config?.label || beautifyObjectName(label ?? fieldName) }}\r\n        </AutoFormLabel>\r\n      </div>\r\n\r\n      <FormDescription v-if=\"config?.description\">\r\n        {{ config.description }}\r\n      </FormDescription>\r\n      <FormMessage />\r\n    </FormItem>\r\n  </FormField>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormFieldDate.vue",
      "content": "<script setup lang=\"ts\">\r\nimport type { FieldProps } from \"./interface\"\r\nimport { DateFormatter, getLocalTimeZone } from \"@internationalized/date\"\r\nimport { CalendarIcon } from \"lucide-vue-next\"\r\nimport { cn } from \"@/lib/utils\"\r\nimport { Button } from \"@/registry/default/ui/button\"\r\nimport { Calendar } from \"@/registry/default/ui/calendar\"\r\n\r\nimport { FormControl, FormDescription, FormField, FormItem, FormMessage } from \"@/registry/default/ui/form\"\r\nimport { Popover, PopoverContent, PopoverTrigger } from \"@/registry/default/ui/popover\"\r\nimport AutoFormLabel from \"./AutoFormLabel.vue\"\r\nimport { beautifyObjectName, maybeBooleanishToBoolean } from \"./utils\"\r\n\r\ndefineProps<FieldProps>()\r\n\r\nconst df = new DateFormatter(\"en-US\", {\r\n  dateStyle: \"long\",\r\n})\r\n</script>\r\n\r\n<template>\r\n  <FormField v-slot=\"slotProps\" :name=\"fieldName\">\r\n    <FormItem>\r\n      <AutoFormLabel v-if=\"!config?.hideLabel\" :required=\"required\">\r\n        {{ config?.label || beautifyObjectName(label ?? fieldName) }}\r\n      </AutoFormLabel>\r\n      <FormControl>\r\n        <slot v-bind=\"slotProps\">\r\n          <div>\r\n            <Popover>\r\n              <PopoverTrigger as-child :disabled=\"maybeBooleanishToBoolean(config?.inputProps?.disabled) ?? disabled\">\r\n                <Button\r\n                  variant=\"outline\"\r\n                  :class=\"cn(\r\n                    'w-full justify-start text-left font-normal',\r\n                    !slotProps.componentField.modelValue && 'text-muted-foreground',\r\n                  )\"\r\n                >\r\n                  <CalendarIcon class=\"mr-2 h-4 w-4\" :size=\"16\" />\r\n                  {{ slotProps.componentField.modelValue ? df.format(slotProps.componentField.modelValue.toDate(getLocalTimeZone())) : \"Pick a date\" }}\r\n                </Button>\r\n              </PopoverTrigger>\r\n              <PopoverContent class=\"w-auto p-0\">\r\n                <Calendar initial-focus v-bind=\"slotProps.componentField\" />\r\n              </PopoverContent>\r\n            </Popover>\r\n          </div>\r\n        </slot>\r\n      </FormControl>\r\n\r\n      <FormDescription v-if=\"config?.description\">\r\n        {{ config.description }}\r\n      </FormDescription>\r\n      <FormMessage />\r\n    </FormItem>\r\n  </FormField>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormFieldEnum.vue",
      "content": "<script setup lang=\"ts\">\r\nimport type { FieldProps } from \"./interface\"\r\nimport { FormControl, FormDescription, FormField, FormItem, FormMessage } from \"@/registry/default/ui/form\"\r\nimport { Label } from \"@/registry/default/ui/label\"\r\nimport { RadioGroup, RadioGroupItem } from \"@/registry/default/ui/radio-group\"\r\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/registry/default/ui/select\"\r\nimport AutoFormLabel from \"./AutoFormLabel.vue\"\r\nimport { beautifyObjectName, maybeBooleanishToBoolean } from \"./utils\"\r\n\r\ndefineProps<FieldProps & {\r\n  options?: string[]\r\n}>()\r\n</script>\r\n\r\n<template>\r\n  <FormField v-slot=\"slotProps\" :name=\"fieldName\">\r\n    <FormItem>\r\n      <AutoFormLabel v-if=\"!config?.hideLabel\" :required=\"required\">\r\n        {{ config?.label || beautifyObjectName(label ?? fieldName) }}\r\n      </AutoFormLabel>\r\n      <FormControl>\r\n        <slot v-bind=\"slotProps\">\r\n          <RadioGroup v-if=\"config?.component === 'radio'\" :disabled=\"maybeBooleanishToBoolean(config?.inputProps?.disabled) ?? disabled\" :orientation=\"'vertical'\" v-bind=\"{ ...slotProps.componentField }\">\r\n            <div v-for=\"(option, index) in options\" :key=\"option\" class=\"mb-2 flex items-center gap-3 space-y-0\">\r\n              <RadioGroupItem :id=\"`${option}-${index}`\" :value=\"option\" />\r\n              <Label :for=\"`${option}-${index}`\">{{ beautifyObjectName(option) }}</Label>\r\n            </div>\r\n          </RadioGroup>\r\n\r\n          <Select v-else :disabled=\"maybeBooleanishToBoolean(config?.inputProps?.disabled) ?? disabled\" v-bind=\"{ ...slotProps.componentField }\">\r\n            <SelectTrigger class=\"w-full\">\r\n              <SelectValue :placeholder=\"config?.inputProps?.placeholder\" />\r\n            </SelectTrigger>\r\n            <SelectContent>\r\n              <SelectItem v-for=\"option in options\" :key=\"option\" :value=\"option\">\r\n                {{ beautifyObjectName(option) }}\r\n              </SelectItem>\r\n            </SelectContent>\r\n          </Select>\r\n        </slot>\r\n      </FormControl>\r\n\r\n      <FormDescription v-if=\"config?.description\">\r\n        {{ config.description }}\r\n      </FormDescription>\r\n      <FormMessage />\r\n    </FormItem>\r\n  </FormField>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormFieldFile.vue",
      "content": "<script setup lang=\"ts\">\r\nimport type { FieldProps } from \"./interface\"\r\nimport { TrashIcon } from \"lucide-vue-next\"\r\nimport { ref } from \"vue\"\r\nimport { Button } from \"@/registry/default/ui/button\"\r\nimport { FormControl, FormDescription, FormField, FormItem, FormMessage } from \"@/registry/default/ui/form\"\r\nimport { Input } from \"@/registry/default/ui/input\"\r\nimport AutoFormLabel from \"./AutoFormLabel.vue\"\r\nimport { beautifyObjectName } from \"./utils\"\r\n\r\ndefineProps<FieldProps>()\r\n\r\nconst inputFile = ref<File>()\r\nasync function parseFileAsString(file: File | undefined): Promise<string> {\r\n  return new Promise((resolve, reject) => {\r\n    if (file) {\r\n      const reader = new FileReader()\r\n      reader.onloadend = () => {\r\n        resolve(reader.result as string)\r\n      }\r\n      reader.onerror = (err) => {\r\n        reject(err)\r\n      }\r\n      reader.readAsDataURL(file)\r\n    }\r\n  })\r\n}\r\n</script>\r\n\r\n<template>\r\n  <FormField v-slot=\"slotProps\" :name=\"fieldName\">\r\n    <FormItem v-bind=\"$attrs\">\r\n      <AutoFormLabel v-if=\"!config?.hideLabel\" :required=\"required\">\r\n        {{ config?.label || beautifyObjectName(label ?? fieldName) }}\r\n      </AutoFormLabel>\r\n      <FormControl>\r\n        <slot v-bind=\"slotProps\">\r\n          <Input\r\n            v-if=\"!inputFile\"\r\n            type=\"file\"\r\n            v-bind=\"{ ...config?.inputProps }\"\r\n            :disabled=\"config?.inputProps?.disabled ?? disabled\"\r\n            @change=\"async (ev: InputEvent) => {\r\n              const file = (ev.target as HTMLInputElement).files?.[0]\r\n              inputFile = file\r\n              const parsed = await parseFileAsString(file)\r\n              slotProps.componentField.onInput(parsed)\r\n            }\"\r\n          />\r\n          <div v-else class=\"flex h-10 w-full items-center justify-between rounded-md border border-input bg-transparent pl-3 pr-1 py-1 text-sm shadow-sm transition-colors\">\r\n            <p>{{ inputFile?.name }}</p>\r\n            <Button\r\n              :size=\"'icon'\"\r\n              :variant=\"'ghost'\"\r\n              class=\"h-[26px] w-[26px]\"\r\n              aria-label=\"Remove file\"\r\n              type=\"button\"\r\n              @click=\"() => {\r\n                inputFile = undefined\r\n                slotProps.componentField.onInput(undefined)\r\n              }\"\r\n            >\r\n              <TrashIcon :size=\"16\" />\r\n            </Button>\r\n          </div>\r\n        </slot>\r\n      </FormControl>\r\n      <FormDescription v-if=\"config?.description\">\r\n        {{ config.description }}\r\n      </FormDescription>\r\n      <FormMessage />\r\n    </FormItem>\r\n  </FormField>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormFieldInput.vue",
      "content": "<script setup lang=\"ts\">\r\nimport type { FieldProps } from \"./interface\"\r\nimport { computed } from \"vue\"\r\nimport { FormControl, FormDescription, FormField, FormItem, FormMessage } from \"@/registry/default/ui/form\"\r\nimport { Input } from \"@/registry/default/ui/input\"\r\nimport { Textarea } from \"@/registry/default/ui/textarea\"\r\nimport AutoFormLabel from \"./AutoFormLabel.vue\"\r\nimport { beautifyObjectName } from \"./utils\"\r\n\r\nconst props = defineProps<FieldProps>()\r\nconst inputComponent = computed(() => props.config?.component === \"textarea\" ? Textarea : Input)\r\n</script>\r\n\r\n<template>\r\n  <FormField v-slot=\"slotProps\" :name=\"fieldName\">\r\n    <FormItem v-bind=\"$attrs\">\r\n      <AutoFormLabel v-if=\"!config?.hideLabel\" :required=\"required\">\r\n        {{ config?.label || beautifyObjectName(label ?? fieldName) }}\r\n      </AutoFormLabel>\r\n      <FormControl>\r\n        <slot v-bind=\"slotProps\">\r\n          <component\r\n            :is=\"inputComponent\"\r\n            type=\"text\"\r\n            v-bind=\"{ ...slotProps.componentField, ...config?.inputProps }\"\r\n            :disabled=\"config?.inputProps?.disabled ?? disabled\"\r\n          />\r\n        </slot>\r\n      </FormControl>\r\n      <FormDescription v-if=\"config?.description\">\r\n        {{ config.description }}\r\n      </FormDescription>\r\n      <FormMessage />\r\n    </FormItem>\r\n  </FormField>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormFieldNumber.vue",
      "content": "<script setup lang=\"ts\">\r\nimport type { FieldProps } from \"./interface\"\r\nimport { FormControl, FormDescription, FormField, FormItem, FormMessage } from \"@/registry/default/ui/form\"\r\nimport { Input } from \"@/registry/default/ui/input\"\r\nimport AutoFormLabel from \"./AutoFormLabel.vue\"\r\nimport { beautifyObjectName } from \"./utils\"\r\n\r\ndefineOptions({\r\n  inheritAttrs: false,\r\n})\r\n\r\ndefineProps<FieldProps>()\r\n</script>\r\n\r\n<template>\r\n  <FormField v-slot=\"slotProps\" :name=\"fieldName\">\r\n    <FormItem>\r\n      <AutoFormLabel v-if=\"!config?.hideLabel\" :required=\"required\">\r\n        {{ config?.label || beautifyObjectName(label ?? fieldName) }}\r\n      </AutoFormLabel>\r\n      <FormControl>\r\n        <slot v-bind=\"slotProps\">\r\n          <Input type=\"number\" v-bind=\"{ ...slotProps.componentField, ...config?.inputProps }\" :disabled=\"config?.inputProps?.disabled ?? disabled\" />\r\n        </slot>\r\n      </FormControl>\r\n      <FormDescription v-if=\"config?.description\">\r\n        {{ config.description }}\r\n      </FormDescription>\r\n      <FormMessage />\r\n    </FormItem>\r\n  </FormField>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormFieldObject.vue",
      "content": "<script setup lang=\"ts\" generic=\"T extends ZodRawShape\">\r\nimport type { ZodAny, ZodObject, ZodRawShape } from \"zod\"\r\nimport type { Config, ConfigItem, Shape } from \"./interface\"\r\nimport { FieldContextKey, useField } from \"vee-validate\"\r\nimport { computed, provide } from \"vue\"\r\nimport { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from \"@/registry/default/ui/accordion\"\r\nimport { FormItem } from \"@/registry/default/ui/form\"\r\nimport AutoFormField from \"./AutoFormField.vue\"\r\nimport AutoFormLabel from \"./AutoFormLabel.vue\"\r\nimport { beautifyObjectName, getBaseSchema, getBaseType, getDefaultValueInZodStack } from \"./utils\"\r\n\r\nconst props = defineProps<{\r\n  fieldName: string\r\n  required?: boolean\r\n  config?: Config<T>\r\n  schema?: ZodObject<T>\r\n  disabled?: boolean\r\n}>()\r\n\r\nconst shapes = computed(() => {\r\n  // @ts-expect-error ignore {} not assignable to object\r\n  const val: { [key in keyof T]: Shape } = {}\r\n\r\n  if (!props.schema)\r\n    return\r\n  const shape = getBaseSchema(props.schema)?.shape\r\n  if (!shape)\r\n    return\r\n  Object.keys(shape).forEach((name) => {\r\n    const item = shape[name] as ZodAny\r\n    const baseItem = getBaseSchema(item) as ZodAny\r\n    let options = (baseItem && \"values\" in baseItem._def) ? baseItem._def.values as string[] : undefined\r\n    if (!Array.isArray(options) && typeof options === \"object\")\r\n      options = Object.values(options)\r\n\r\n    val[name as keyof T] = {\r\n      type: getBaseType(item),\r\n      default: getDefaultValueInZodStack(item),\r\n      options,\r\n      required: ![\"ZodOptional\", \"ZodNullable\"].includes(item._def.typeName),\r\n      schema: item,\r\n    }\r\n  })\r\n  return val\r\n})\r\n\r\nconst fieldContext = useField(props.fieldName)\r\n// @ts-expect-error ignore missing `id`\r\nprovide(FieldContextKey, fieldContext)\r\n</script>\r\n\r\n<template>\r\n  <section>\r\n    <slot v-bind=\"props\">\r\n      <Accordion type=\"single\" as-child class=\"w-full\" collapsible :disabled=\"disabled\">\r\n        <FormItem>\r\n          <AccordionItem :value=\"fieldName\" class=\"border-none\">\r\n            <AccordionTrigger>\r\n              <AutoFormLabel class=\"text-base\" :required=\"required\">\r\n                {{ schema?.description || beautifyObjectName(fieldName) }}\r\n              </AutoFormLabel>\r\n            </AccordionTrigger>\r\n            <AccordionContent class=\"p-1 space-y-5\">\r\n              <template v-for=\"(shape, key) in shapes\" :key=\"key\">\r\n                <AutoFormField\r\n                  :config=\"config?.[key as keyof typeof config] as ConfigItem\"\r\n                  :field-name=\"`${fieldName}.${key.toString()}`\"\r\n                  :label=\"key.toString()\"\r\n                  :shape=\"shape\"\r\n                />\r\n              </template>\r\n            </AccordionContent>\r\n          </AccordionItem>\r\n        </FormItem>\r\n      </Accordion>\r\n    </slot>\r\n  </section>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/AutoFormLabel.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { FormLabel } from \"@/registry/default/ui/form\"\r\n\r\ndefineProps<{\r\n  required?: boolean\r\n}>()\r\n</script>\r\n\r\n<template>\r\n  <FormLabel>\r\n    <slot />\r\n    <span v-if=\"required\" class=\"text-destructive\"> *</span>\r\n  </FormLabel>\r\n</template>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/constant.ts",
      "content": "import type { InputComponents } from \"./interface\"\r\nimport AutoFormFieldArray from \"./AutoFormFieldArray.vue\"\r\nimport AutoFormFieldBoolean from \"./AutoFormFieldBoolean.vue\"\r\nimport AutoFormFieldDate from \"./AutoFormFieldDate.vue\"\r\nimport AutoFormFieldEnum from \"./AutoFormFieldEnum.vue\"\r\nimport AutoFormFieldFile from \"./AutoFormFieldFile.vue\"\r\nimport AutoFormFieldInput from \"./AutoFormFieldInput.vue\"\r\nimport AutoFormFieldNumber from \"./AutoFormFieldNumber.vue\"\r\nimport AutoFormFieldObject from \"./AutoFormFieldObject.vue\"\r\n\r\nexport const INPUT_COMPONENTS: InputComponents = {\r\n  date: AutoFormFieldDate,\r\n  select: AutoFormFieldEnum,\r\n  radio: AutoFormFieldEnum,\r\n  checkbox: AutoFormFieldBoolean,\r\n  switch: AutoFormFieldBoolean,\r\n  textarea: AutoFormFieldInput,\r\n  number: AutoFormFieldNumber,\r\n  string: AutoFormFieldInput,\r\n  file: AutoFormFieldFile,\r\n  array: AutoFormFieldArray,\r\n  object: AutoFormFieldObject,\r\n}\r\n\r\n/**\r\n * Define handlers for specific Zod types.\r\n * You can expand this object to support more types.\r\n */\r\nexport const DEFAULT_ZOD_HANDLERS: {\r\n  [key: string]: keyof typeof INPUT_COMPONENTS\r\n} = {\r\n  ZodString: \"string\",\r\n  ZodBoolean: \"checkbox\",\r\n  ZodDate: \"date\",\r\n  ZodEnum: \"select\",\r\n  ZodNativeEnum: \"select\",\r\n  ZodNumber: \"number\",\r\n  ZodArray: \"array\",\r\n  ZodObject: \"object\",\r\n}\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/dependencies.ts",
      "content": "import type { Ref } from \"vue\"\r\nimport type * as z from \"zod\"\r\nimport type { Dependency, EnumValues } from \"./interface\"\r\nimport { createContext } from \"reka-ui\"\r\nimport { useFieldValue, useFormValues } from \"vee-validate\"\r\nimport { computed, ref, watch } from \"vue\"\nimport { DependencyType } from \"./interface\"\r\nimport { getFromPath, getIndexIfArray } from \"./utils\"\r\n\r\nexport const [injectDependencies, provideDependencies] = createContext<Ref<Dependency<z.infer<z.ZodObject<any>>>[] | undefined>>(\"AutoFormDependencies\")\r\n\r\nexport default function useDependencies(\r\n  fieldName: string,\r\n) {\r\n  const form = useFormValues()\r\n  // parsed test[0].age => test.age\r\n  const currentFieldName = fieldName.replace(/\\[\\d+\\]/g, \"\")\r\n  const currentFieldValue = useFieldValue<any>(fieldName)\r\n\r\n  if (!form)\r\n    throw new Error(\"useDependencies should be used within <AutoForm>\")\r\n\r\n  const dependencies = injectDependencies()\r\n  const isDisabled = ref(false)\r\n  const isHidden = ref(false)\r\n  const isRequired = ref(false)\r\n  const overrideOptions = ref<EnumValues | undefined>()\r\n\r\n  const currentFieldDependencies = computed(() => dependencies.value?.filter(\r\n    dependency => dependency.targetField === currentFieldName,\r\n  ))\r\n\r\n  function getSourceValue(dep: Dependency<any>) {\r\n    const source = dep.sourceField as string\r\n    const index = getIndexIfArray(fieldName) ?? -1\r\n    const [sourceLast, ...sourceInitial] = source.split(\".\").toReversed()\r\n    const [_targetLast, ...targetInitial] = (dep.targetField as string).split(\".\").toReversed()\r\n\r\n    if (index >= 0 && sourceInitial.join(\",\") === targetInitial.join(\",\")) {\r\n      const [_currentLast, ...currentInitial] = fieldName.split(\".\").toReversed()\r\n      return getFromPath(form.value, currentInitial.join(\".\") + sourceLast)\r\n    }\r\n\r\n    return getFromPath(form.value, source)\r\n  }\r\n\r\n  const sourceFieldValues = computed(() => currentFieldDependencies.value?.map(dep => getSourceValue(dep)))\r\n\r\n  const resetConditionState = () => {\r\n    isDisabled.value = false\r\n    isHidden.value = false\r\n    isRequired.value = false\r\n    overrideOptions.value = undefined\r\n  }\r\n\r\n  watch([sourceFieldValues, dependencies], () => {\r\n    resetConditionState()\r\n    currentFieldDependencies.value?.forEach((dep) => {\r\n      const sourceValue = getSourceValue(dep)\r\n      const conditionMet = dep.when(sourceValue, currentFieldValue.value)\r\n\r\n      switch (dep.type) {\r\n        case DependencyType.DISABLES:\r\n          if (conditionMet)\r\n            isDisabled.value = true\r\n\r\n          break\r\n        case DependencyType.REQUIRES:\r\n          if (conditionMet)\r\n            isRequired.value = true\r\n\r\n          break\r\n        case DependencyType.HIDES:\r\n          if (conditionMet)\r\n            isHidden.value = true\r\n\r\n          break\r\n        case DependencyType.SETS_OPTIONS:\r\n          if (conditionMet)\r\n            overrideOptions.value = dep.options\r\n\r\n          break\r\n      }\r\n    })\r\n  }, { immediate: true, deep: true })\r\n\r\n  return {\r\n    isDisabled,\r\n    isHidden,\r\n    isRequired,\r\n    overrideOptions,\r\n  }\r\n}\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/index.ts",
      "content": "export { default as AutoForm } from \"./AutoForm.vue\"\r\nexport { default as AutoFormField } from \"./AutoFormField.vue\"\r\n\r\nexport { default as AutoFormFieldArray } from \"./AutoFormFieldArray.vue\"\r\nexport { default as AutoFormFieldBoolean } from \"./AutoFormFieldBoolean.vue\"\r\nexport { default as AutoFormFieldDate } from \"./AutoFormFieldDate.vue\"\r\n\r\nexport { default as AutoFormFieldEnum } from \"./AutoFormFieldEnum.vue\"\r\nexport { default as AutoFormFieldFile } from \"./AutoFormFieldFile.vue\"\r\nexport { default as AutoFormFieldInput } from \"./AutoFormFieldInput.vue\"\r\nexport { default as AutoFormFieldNumber } from \"./AutoFormFieldNumber.vue\"\r\nexport { default as AutoFormFieldObject } from \"./AutoFormFieldObject.vue\"\r\nexport { default as AutoFormLabel } from \"./AutoFormLabel.vue\"\r\nexport type { Config, ConfigItem, FieldProps } from \"./interface\"\r\nexport { getBaseSchema, getBaseType, getObjectFormSchema } from \"./utils\"\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/interface.ts",
      "content": "import type { Component, InputHTMLAttributes } from \"vue\"\r\nimport type { z, ZodAny } from \"zod\"\r\nimport type { INPUT_COMPONENTS } from \"./constant\"\r\n\r\nexport interface FieldProps {\r\n  fieldName: string\r\n  label?: string\r\n  required?: boolean\r\n  config?: ConfigItem\r\n  disabled?: boolean\r\n}\r\n\r\nexport interface Shape {\r\n  type: string\r\n  default?: any\r\n  required?: boolean\r\n  options?: string[]\r\n  schema?: ZodAny\r\n}\r\n\r\nexport interface InputComponents {\r\n  date: Component\r\n  select: Component\r\n  radio: Component\r\n  checkbox: Component\r\n  switch: Component\r\n  textarea: Component\r\n  number: Component\r\n  string: Component\r\n  file: Component\r\n  array: Component\r\n  object: Component\r\n};\r\n\r\nexport interface ConfigItem {\r\n  /** Value for the `FormLabel` */\r\n  label?: string\r\n  /** Value for the `FormDescription` */\r\n  description?: string\r\n  /** Pick which component to be rendered. */\r\n  component?: keyof typeof INPUT_COMPONENTS | Component\r\n  /** Hide `FormLabel`. */\r\n  hideLabel?: boolean\r\n  inputProps?: InputHTMLAttributes\r\n}\r\n\r\n// Define a type to unwrap an array\r\ntype UnwrapArray<T> = T extends (infer U)[] ? U : never\r\n\r\nexport type Config<SchemaType extends object> = {\r\n  // If SchemaType.key is an object, create a nested Config, otherwise ConfigItem\r\n  [Key in keyof SchemaType]?:\r\n  SchemaType[Key] extends any[]\r\n    ? UnwrapArray<Config<SchemaType[Key]>>\r\n    : SchemaType[Key] extends object\r\n      ? Config<SchemaType[Key]>\r\n      : ConfigItem;\r\n}\r\n\r\nexport enum DependencyType {\r\n  DISABLES,\r\n  REQUIRES,\r\n  HIDES,\r\n  SETS_OPTIONS,\r\n}\r\n\r\ninterface BaseDependency<SchemaType extends z.infer<z.ZodObject<any, any>>> {\r\n  sourceField: keyof SchemaType\r\n  type: DependencyType\r\n  targetField: keyof SchemaType\r\n  when: (sourceFieldValue: any, targetFieldValue: any) => boolean\r\n}\r\n\r\nexport type ValueDependency<SchemaType extends z.infer<z.ZodObject<any, any>>>\r\n  = BaseDependency<SchemaType> & {\r\n    type:\r\n      | DependencyType.DISABLES\r\n      | DependencyType.REQUIRES\r\n      | DependencyType.HIDES\r\n  }\r\n\r\nexport type EnumValues = readonly [string, ...string[]]\r\n\r\nexport type OptionsDependency<\r\n  SchemaType extends z.infer<z.ZodObject<any, any>>,\r\n> = BaseDependency<SchemaType> & {\r\n  type: DependencyType.SETS_OPTIONS\r\n\r\n  // Partial array of values from sourceField that will trigger the dependency\r\n  options: EnumValues\r\n}\r\n\r\nexport type Dependency<SchemaType extends z.infer<z.ZodObject<any, any>>>\r\n  = | ValueDependency<SchemaType>\r\n    | OptionsDependency<SchemaType>\r\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/auto-form/utils.ts",
      "content": "import type { z } from \"zod\"\r\n\r\n// TODO: This should support recursive ZodEffects but TypeScript doesn't allow circular type definitions.\r\nexport type ZodObjectOrWrapped\r\n  = | z.ZodObject<any, any>\r\n    | z.ZodEffects<z.ZodObject<any, any>>\r\n\r\n/**\r\n * Beautify a camelCase string.\r\n * e.g. \"myString\" -> \"My String\"\r\n */\r\nexport function beautifyObjectName(string: string) {\r\n  // Remove bracketed indices\r\n  // if numbers only return the string\r\n  let output = string.replace(/\\[\\d+\\]/g, \"\").replace(/([A-Z])/g, \" $1\")\r\n  output = output.charAt(0).toUpperCase() + output.slice(1)\r\n  return output\r\n}\r\n\r\n/**\r\n * Parse string and extract the index\r\n * @param string\r\n * @returns index or undefined\r\n */\r\nexport function getIndexIfArray(string: string) {\r\n  const indexRegex = /\\[(\\d+)\\]/\r\n  // Match the index\r\n  const match = string.match(indexRegex)\r\n  // Extract the index (number)\r\n  const index = match ? Number.parseInt(match[1]) : undefined\r\n  return index\r\n}\r\n\r\n/**\r\n * Get the lowest level Zod type.\r\n * This will unpack optionals, refinements, etc.\r\n */\r\nexport function getBaseSchema<\r\n  ChildType extends z.ZodAny | z.AnyZodObject = z.ZodAny,\r\n>(schema: ChildType | z.ZodEffects<ChildType>): ChildType | null {\r\n  if (!schema)\r\n    return null\r\n  if (\"innerType\" in schema._def)\r\n    return getBaseSchema(schema._def.innerType as ChildType)\r\n\r\n  if (\"schema\" in schema._def)\r\n    return getBaseSchema(schema._def.schema as ChildType)\r\n\r\n  return schema as ChildType\r\n}\r\n\r\n/**\r\n * Get the type name of the lowest level Zod type.\r\n * This will unpack optionals, refinements, etc.\r\n */\r\nexport function getBaseType(schema: z.ZodAny) {\r\n  const baseSchema = getBaseSchema(schema)\r\n  return baseSchema ? baseSchema._def.typeName : \"\"\r\n}\r\n\r\n/**\r\n * Search for a \"ZodDefault\" in the Zod stack and return its value.\r\n */\r\nexport function getDefaultValueInZodStack(schema: z.ZodAny): any {\r\n  const typedSchema = schema as unknown as z.ZodDefault<\r\n    z.ZodNumber | z.ZodString\r\n  >\r\n\r\n  if (typedSchema._def.typeName === \"ZodDefault\")\r\n    return typedSchema._def.defaultValue()\r\n\r\n  if (\"innerType\" in typedSchema._def) {\r\n    return getDefaultValueInZodStack(\r\n      typedSchema._def.innerType as unknown as z.ZodAny,\r\n    )\r\n  }\r\n  if (\"schema\" in typedSchema._def) {\r\n    return getDefaultValueInZodStack(\r\n      (typedSchema._def as any).schema as z.ZodAny,\r\n    )\r\n  }\r\n\r\n  return undefined\r\n}\r\n\r\nexport function getObjectFormSchema(\r\n  schema: ZodObjectOrWrapped,\r\n): z.ZodObject<any, any> {\r\n  if (schema?._def.typeName === \"ZodEffects\") {\r\n    const typedSchema = schema as z.ZodEffects<z.ZodObject<any, any>>\r\n    return getObjectFormSchema(typedSchema._def.schema)\r\n  }\r\n  return schema as z.ZodObject<any, any>\r\n}\r\n\r\nfunction isIndex(value: unknown): value is number {\r\n  return Number(value) >= 0\r\n}\r\n/**\r\n * Constructs a path with dot paths for arrays to use brackets to be compatible with vee-validate path syntax\r\n */\r\nexport function normalizeFormPath(path: string): string {\r\n  const pathArr = path.split(\".\")\r\n  if (!pathArr.length)\r\n    return \"\"\r\n\r\n  let fullPath = String(pathArr[0])\r\n  for (let i = 1; i < pathArr.length; i++) {\r\n    if (isIndex(pathArr[i])) {\r\n      fullPath += `[${pathArr[i]}]`\r\n      continue\r\n    }\r\n\r\n    fullPath += `.${pathArr[i]}`\r\n  }\r\n\r\n  return fullPath\r\n}\r\n\r\ntype NestedRecord = Record<string, unknown> | { [k: string]: NestedRecord }\r\n/**\r\n * Checks if the path opted out of nested fields using `[fieldName]` syntax\r\n */\r\nexport function isNotNestedPath(path: string) {\r\n  return /^\\[.+\\]$/.test(path)\r\n}\r\nfunction isObject(obj: unknown): obj is Record<string, unknown> {\r\n  return obj !== null && !!obj && typeof obj === \"object\" && !Array.isArray(obj)\r\n}\r\nfunction isContainerValue(value: unknown): value is Record<string, unknown> {\r\n  return isObject(value) || Array.isArray(value)\r\n}\r\nfunction cleanupNonNestedPath(path: string) {\r\n  if (isNotNestedPath(path))\r\n    return path.replace(/\\[|\\]/g, \"\")\r\n\r\n  return path\r\n}\r\n\r\n/**\r\n * Gets a nested property value from an object\r\n */\r\nexport function getFromPath<TValue = unknown>(object: NestedRecord | undefined, path: string): TValue | undefined\r\nexport function getFromPath<TValue = unknown, TFallback = TValue>(\r\n  object: NestedRecord | undefined,\r\n  path: string,\r\n  fallback?: TFallback,\r\n): TValue | TFallback\r\nexport function getFromPath<TValue = unknown, TFallback = TValue>(\r\n  object: NestedRecord | undefined,\r\n  path: string,\r\n  fallback?: TFallback,\r\n): TValue | TFallback | undefined {\r\n  if (!object)\r\n    return fallback\r\n\r\n  if (isNotNestedPath(path))\r\n    return object[cleanupNonNestedPath(path)] as TValue | undefined\r\n\r\n  const resolvedValue = (path || \"\")\r\n    .split(/\\.|\\[(\\d+)\\]/)\r\n    .filter(Boolean)\r\n    .reduce((acc, propKey) => {\r\n      if (isContainerValue(acc) && propKey in acc)\r\n        return acc[propKey]\r\n\r\n      return fallback\r\n    }, object as unknown)\r\n\r\n  return resolvedValue as TValue | undefined\r\n}\r\n\r\ntype Booleanish = boolean | \"true\" | \"false\"\r\n\r\nexport function booleanishToBoolean(value: Booleanish) {\r\n  switch (value) {\r\n    case \"true\":\r\n    case true:\r\n      return true\r\n    case \"false\":\r\n    case false:\r\n      return false\r\n  }\r\n}\r\n\r\nexport function maybeBooleanishToBoolean(value?: Booleanish) {\r\n  return value ? booleanishToBoolean(value) : undefined\r\n}\r\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}
